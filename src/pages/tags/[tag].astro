---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PostCard from '../../components/PostCard.astro';
import { getCollection } from 'astro:content';
import { pickCover, resolveMaybeRelativeUrl } from '../../utils/contentPreview';
import { formatShanghai } from '../../utils/dateFormat';

type Item = {
  kind: 'writing' | 'now';
  href: string;
  title: string;
  description?: string;
  pubDate: Date;
  tags: string[];
  cover?: string | null;
};

export async function getStaticPaths() {
  const writingPosts = (await getCollection('writing')).filter((p) => !p.data.draft);
  const nowPosts = (await getCollection('now')).filter((p) => !p.data.draft);

  const tagSet = new Set<string>();
  for (const p of [...writingPosts, ...nowPosts]) {
    for (const t of p.data.tags ?? []) tagSet.add(t);
  }

  // Ensure nav-linked tags always have a generated page, even if empty.
  // (Otherwise /tags/<tag>/ would 404 when there are currently no posts for that tag.)
  for (const t of ['ai', 'game', 'life']) tagSet.add(t);

  return [...tagSet].map((tag) => ({
    params: { tag: encodeURIComponent(tag) },
    props: { tag },
  }));
}

const { tag } = Astro.props;

const writingPosts = (await getCollection('writing'))
  .filter((p) => !p.data.draft)
  .filter((p) => (p.data.tags ?? []).includes(tag))
  .map((p) => {
    const slug = p.slug.replace(/\/index$/, '');
    const href = `/writing/${slug}/`;
    const coverRaw = pickCover(p);
    const cover = coverRaw ? resolveMaybeRelativeUrl(coverRaw, href) : null;
    return {
      kind: 'writing',
      href,
      title: p.data.title,
      description: p.data.description,
      pubDate: p.data.pubDate,
      tags: p.data.tags,
      cover,
    } satisfies Item;
  });

const nowPosts = (await getCollection('now'))
  .filter((p) => !p.data.draft)
  .filter((p) => (p.data.tags ?? []).includes(tag))
  .map((p) => {
    const slug = p.slug.replace(/\/index$/, '');
    const href = `/now/${slug}/`;
    const coverRaw = pickCover(p);
    const cover = coverRaw ? resolveMaybeRelativeUrl(coverRaw, href) : null;
    return {
      kind: 'now',
      href,
      title: p.data.title,
      description: p.data.description,
      pubDate: p.data.pubDate,
      tags: p.data.tags,
      cover,
    } satisfies Item;
  });

const posts = [...writingPosts, ...nowPosts].sort((a, b) => b.pubDate.getTime() - a.pubDate.getTime());
---

<BaseLayout title={`${tag} | Tags | 唐靖凯`} description={`标签：${tag}`}>
  <section class="section glass" style="max-width: 900px;">
    <div class="section-head">
      <h2>#{tag}</h2>
      <p>{posts.length} 条</p>
    </div>

    <div style="display:grid; gap:16px; margin-top: 12px;">
      {posts.map((post) => {
        const cleanTitle = post.title.replace(/^Now:\s*/, '');
        return (
          <PostCard
            href={post.href}
            title={cleanTitle}
            description={post.description}
            dateText={formatShanghai(post.pubDate, { withSeconds: true })}
            tags={post.tags}
            cover={post.cover}
            badge={post.kind === 'now' ? 'Now' : 'Writing'}
            showReadMore={true}
            ariaLabel={`阅读全文：${cleanTitle}`}
          />
        );
      })}

      {posts.length === 0 ? <p style="color: var(--muted);">还没有内容。</p> : null}
    </div>

    <p style="margin-top: 18px;"><a href="/tags">← 返回标签列表</a></p>
  </section>
</BaseLayout>
